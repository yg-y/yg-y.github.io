# 基于 HotSpot 的 JAVA 虚拟机参数概览

> 记录在 JVM 启动参数设置时需要调整的一些参数，使其符合各类服务的运行环境，此文章以 JDK1.8 HotSpot 虚拟机为例
> 展示对应的虚拟器参数，不同版本的 JDK 及不同版本的虚拟器，参数或多或少会有区别，请以官方文档为准。

## 堆内存
> 堆内存是 JAVA 虚拟器 GC 操作最频繁的一块内存区域，也是 JAVA 虚拟机所管理的内存中最大的一块，
> JAVA 虚拟机堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。

### 默认堆大小

>如果没有指定堆大小，则会根据计算机的内存量来计算，默认的最大堆大小是物理内存的一半，最大物理内存为192兆字节(MB) ，
其他情况下是物理内存的四分之一，最大物理内存为 1 GB。
>
>例如，如果您的计算机有128 MB 的物理内存，那么最大堆大小为64 MB，大于或等于1 GB 的物理内存将导致最大堆大小为256 MB。
>
> 摘自 Oracle 官网

- 参数
    - heap size 表示要初始化内存的具体大小。
    - unit 表示要初始化内存的单位。单位为g、m、k。
```yaml
-Xms<heap size>[unit] 
-Xmx<heap size>[unit]
```
### 指定堆内存
- 指定最小堆内存
```yaml
-Xms2g
```  

- 指定最大堆内存
```yaml
-Xmx5g
```


### 指定堆内存中新生代大小 ( Young Generation )
> 除了总的可用内存之外，影响垃圾收集性能的第二个最重要的因素是专用于新生代的堆的比例。新生代内存越多，minor GC 就越少。
> 然而，对于有限的堆大小，较大的新生代空间意味着较老的一代空间越少，这将增加 major GC 的频率。
> 最佳选择取决于应用程序分配的对象的生命周期分布。

- 指定堆内存中新生代大小 —— 默认方式

> 默认情况下，新生代的大小由参数 NewRatio 控制。例如，设置 -XX: NewRatio = 3 意味着新生代和老年代之间的比率为1:3。换句话说，eden 和 survivor 空间的总和将是堆总大小的四分之一。

```yaml
-XX: NewRatio = 3
```

- 指定堆内存中新生代大小 —— 固定大小

> NewSize 和 MaxNewSize 从参数上限定了新生代的大小。

- 指定最小值
```yaml
-XX:NewSize=256m
```

- 指定最大值
```yaml
-XX:MaxNewSize=1024m

// 此设置表示新生代大小无限制
-XX:MaxNewSize=not limited
```

- 若要将堆中新生代大小设置成固定值
```yaml
-Xmn256m 
```

#### Oracle 官方给出堆新生代大小设置建议
- 首先确定给虚拟机提供的最大堆大小。然后根据新生代的大小来计算你的性能指标，以找到最佳的设置。
  - 请注意，最大堆大小应该始终小于安装在计算机上的内存量，以避免出现过多的页面错误和抖动。
- 如果总堆大小是固定的，那么增加新生代的大小就需要减小老年代的大小。保持老年代足够大，以容纳应用程序在任何给定时间使用的所有实时数据，再加上一定数量的闲置空间(10% 至20% 或更多)。
- 给予新生代足够的内存。
- 随着处理器数量的增加，增加新生代的大小，因为分配可以并行化。

### 指定永久代/元空间的大小
> JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是本地内存。

- 设置 Metaspace 的初始（和最小大小）
```yaml
-XX:MetaspaceSize=256m
```

- 设置 Metaspace 的最大大小，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。
```yaml
-XX:MaxMetaspaceSize=512m
```

## 垃圾收集
### 什么是自动垃圾收集？

> 自动垃圾收集是查看堆内存、确定哪些对象正在使用，哪些没有使用，以及删除未使用的对象的过程。一个正在使用的对象，或者一个被引用的对象，意味着程序的某些部分仍然维护着一个指向该对象的指针。程序的任何部分都不再引用未使用的对象或未引用的对象。因此，可以回收未引用对象使用的内存。

在 c 这样的编程语言中，分配和释放内存是一个手动过程。在 Java 中，释放内存的过程由垃圾收集器自动处理。基本过程可以描述如下。
- Step 1: Marking(标记)
- Step 2: Normal Deletion(正常删除)
- Step 2a: Deletion with Compacting(用压缩操作删除)

### 为什么要进行分代垃圾收集？

如前所述，必须标记和压缩 JVM 中的所有对象是低效的。随着越来越多的对象被分配，对象列表会不断增长，导致垃圾收集时间越来越长。然而，对应用程序的实证分析表明，大多数对象都是短暂的。

![Snipaste_2021-03-26_14-26-14.png](http://ww1.sinaimg.cn/large/a760927bgy1goxahse21gj20dg09agm1.jpg)

正如您所看到的，随着时间的推移，仍然分配的对象越来越少。事实上，大多数对象的生命周期都很短，这从图左侧较高的值可以看出来。

从对象分配行为中获得的信息可用于增强 JVM 的性能。因此，堆被分解为更小的部分或代。堆的部分是: 年轻代，老年代，和永久代

年轻一代是所有新对象被分配和陈旧的地方。当年轻一代填满时，这将导致一次次要的垃圾收集。假设对象死亡率较高，可以对小型收集进行优化。年轻一代收集尸体的速度非常快。一些幸存下来的物品已经老化，最终会传递给老一代

### JVM具有四种类型的GC实现：

- 串行垃圾收集器

> Serial GC 是大多数应用程序的首选垃圾收集器，这些应用程序的暂停时间要求不低，可以在客户机风格的机器上运行。
它只利用单个虚拟处理器进行垃圾收集工作(因此，它的名称)。
尽管如此，在今天的硬件上，Serial GC 可以使用几百 mb 的 Java 堆高效地管理大量非琐碎的应用程序，
最坏情况下的暂停时间相对较短(对于完整的垃圾收集，大约为几秒钟)。
> 
> Serial GC 的另一个流行用途是在同一台机器上运行大量 jvm 的环境中(在某些情况下，比可用的处理器运行更多的 jvm!).在这种环境中，当 JVM 执行垃圾收集时，最好只使用一个处理器，以尽量减少对剩余 JVM 的干扰，即使垃圾收集可能持续更长时间。序列 GC 非常适合这种折衷。

- 并行垃圾收集器
>  并行垃圾收集器使用多个线程执行新生代的垃圾收集。在具有 n 个 cpu 的主机上，默认情况下，并行垃圾回收器在回收中使用 n 个垃圾回收器线程。垃圾收集器线程的数量可以通过命令行选项来控制:-XX: ParallelGCThreads = < 所需的数量 >
> 
> 在只有一个 CPU 的主机上，即使请求了并行垃圾收集器，也会使用默认垃圾收集器。在有两个 cpu 的主机上，并行垃圾收集器的性能通常和默认垃圾收集器一样好，并且在有两个以上 cpu 的主机上，新生代的生成/容量垃圾收集器的暂停时间可能会减少。并行 GC 有两种形式。

- CMS垃圾收集器
>  并发标记扫描(CMS)收集器(也称为并发低暂停收集器)收集年老代 。它试图通过与应用程序线程并发地执行大部分垃圾收集工作来最小化垃圾收集引起的暂停。通常，并发的低暂停收集器不会复制或压缩活动对象。垃圾收集是在不移动活动对象的情况下完成的。如果碎片成为一个问题，分配一个更大的堆。

- G1垃圾收集器
>垃圾第一或 G1垃圾收集器在 java7中可用，被设计为 CMS 收集器的长期替代品。G1收集器是一个并行、并发和增量压缩的低暂停垃圾收集器，它的布局与前面描述的其他垃圾收集器完全不同

可以使用以下参数声明这些实现：

```yaml
// 串行垃圾收集器
-XX:+UseSerialGC

// 并行垃圾收集器
-XX:+UseParallelGC

// CMS垃圾收集器
-XX:+USeParNewGC

// G1垃圾收集器
-XX:+UseG1GC
```


















