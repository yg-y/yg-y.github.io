# 深入理解JVM虚拟机笔记输出

# 第一章 走进JAVA
> java虚拟机家族
- Sun Classic Exact VM
- HotSpot VM
- Mobile Embedded VM
- EBA JRockit IBM J9 VM
- BEA Liquid VM
- Azul VM
- Apache Harmony Google Android Dalvik VM
- Microsoft JVM

# 第二章 Java内存区域与内存溢出异常

## 运行时数据区域
java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。

### 程序计数器
是一块较小的空间，他可以看做是当前线程所执行的字节码的行号指示器。

### Java虚拟机栈
线程私有的，生命周期与线程相同。虚拟机栈描述的是java方法执行的线程内存模型：每个方法被执行的时候，java虚拟机都会同步一个栈帧用于储存局部变量表，操作数栈，动态连接，方法出口等信息。

栈通常指虚拟机栈，或者更多情况下指虚拟机栈中局部变量表部分

局部变量表存放了编译器可知的各种java虚拟机基本数据类型(boolean/byte/char/short/int/float/long/double)、对象引用和returnAddress类型

这些数据类型在局部变量表中的储存空间以局部变量槽来表示，64位长度的long和double数据类型占两个变量槽，其余占一个槽

《Java虚拟机规范中》对这个内存区域规定了两类异常情况。线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverFlowError，
 java虚拟机栈容量可以动态扩展，当扩展时无法申请到足够的内存，将抛出OutOfMenoryError
 
### Java堆 
 java堆是虚拟机所管理的内存中最大的一块。是被所有线程共享的一块区域。虚拟机启动时创建。唯一目的是存放对象实例
 
 java堆是垃圾收集器管理的内存区域，因此也被叫做 GC堆 
 
 从内存回收角度看，由于现代垃圾收集器大部分都是基于分代收集理论设计的，所以java堆中经常出现“新生代”、“老年代”、“永久代”、“Eden空间”、“From Survivor”等名词。
 
 这些区域划分仅仅是垃圾回收器的共同特性或设计风格，并非java虚拟机的固有内存布局。
 
 将java堆细分的目的是更好的回收内存和分配内存
 
 java堆既可以被实现成固定大小，也可以是可扩展的，主流java虚拟机可以通过参数 -Xmx -Xms 设定
 
 java堆中没有完成实例分配，并且堆也无法再扩展时，java虚拟机会抛出OutOfMemoryError
 
### 方法区
 线程共享的内存区域，用于储存被虚拟机加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据
 
 JDK8之前很多人称方法区为“永久代”，或将两者混为一谈。本质两者不等价。
 
 JDK6时HotSpot开始放弃永久代，逐步改为本地内存来实现方法区
 JDK7把原本放在永久代的字符串常量池，静态变量等移除
 JDK8完全放弃永久代，改用本地内存实现的元空间来代替
 
 如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError
 
### 运行时常量池
 是方法区的一部分
 class文件中除了有类的版本、字段。方法。接口等描述信息外，还有是常量池表，用于存放编译器生成的各种字面变量与符号引用。这部分在类加载后放到方法区的运行时常量池中
 
### 直接内存
 不是虚拟机运行时数据区域的一部分。
 
 JDK1.4中NIO，可使用Native函数库直接分配堆外内存
 
 也会出现OOM异常
 
## HotSpot虚拟机对象
 
### 对象的创建
 1.虚拟机接收到一条字节码时，首先检查这个指令的参是否能够在常量池中定位到一个类的符号引用，没有则执行类加载过程
 2.类加载检查通过后，虚拟机为新对象分配内存，内存大小加载后确定
 3.内存分配完成之后，虚拟机将分配到的内存空间（除对象头）都初始化为零值
 4.虚拟机对对象进行必要的设置，如对象是哪个类的实例，如何才能找到类的元数据信息，对象哈希码，对象GC分代年龄信息，存放在对象头中。
 以上从虚拟机角度，对象创建完成
 但从Java程序角度，一个新的对象才刚刚开始——构造函数 如执行class文件中 init 方法
 
 
### 对象的内存布局
 对象头(Header)、实例数据(instance data)、对齐填充(padding)
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 








